# Take the Green Pill

The Elixir programming language wraps functional programming with
immutable state and an actor-based approach to concurrency in a tidy,
modern syntax. And it runs on the industrial strength, high
performance, distributed Erlang VM.  But what does all that mean?

It means you can stop worrying about many of the difficult things that
currently consume your time. You no longer have to think too hard
about protecting your data consistency in a multi-threaded
environment. It means that you worry less about scaling your
applications. And, most importantly, it means that you can think about
programming in a different way.


## Programming Should Be About Transforming Data

If you come from an object-oriented world, then you are used to
thinking in terms of classes and their instances. A class defines
behavior, and objects hold state. Developers spend time coming up with
intricate hierarchies of classes that try to model their problem, much
as Victorian gentlemen scientists created taxonomies of butterflies.

When you code with objects, you're thinking about state. Much of your
time is spent calling methods in objects, passing them other
objects. Based on these calls, objects update their own state, and
possibly the state of other objects. In this world, the class is
king—it defines what each instance can do, and it implicitly controls
the state of the data its instances hold. Your goal is data hiding.

But that's not the real world. In the real world, I don't want to
model abstract hierarchies (because, in reality, there aren't that
many true hierarchies out there). I want to get things done,
not maintain state.

I don't want to hide data. I want to transform it.

Right now, I'm taking empty computer files and transforming them into files
containing text. At some point, I'll transform those files into some
format you can read. A web server somewhere will transform your
request to download the book into an HTTP response containing the
content.

### Combine Transformations with Pipelines

Unix users are very used to the philosophy of small, focused command
line tools that can be combined in arbitrary ways. Each tool takes an
input, transforms it, and writes the result in a format that can be
used by the next tool (or by a human).

It is incredibly flexible, and leads to fantastic reuse. The Unix
utilities can be combined in ways undreamed of by their authors. And
each one multiplies the potential of the others.

It's also highly reliable—each small program does one thing well,
which makes it easier to test.

There's another benefit. A pipeline of functions can operate in
parallel. If I write

{: language="session"}
~~~
$ grep Elixir *.pml | wc -l
~~~

the word count program, `wc`, runs at the same time as the `grep`
command. Because `wc` consumes `grep`'s output as it is produced, the answer is ready
with virtually no delay once `grep` finishes.

Just to give you a taste of this kind of thing, here's an Elixir
function called `pmap`. It takes a collection and a function, and
returns the list that results from applying that function to each
element of the collection. But…it runs a separate process to do the
conversion of each element.

<embed file="code/spawn/pmap.exs" showname="no"/>

We could run this function to get the squares of the numbers from 1 to
1000.

<iex test="no">
result = Parallel.pmap 1..1000, &(&1 * &1)
</iex>

And, yes, I just kicked off 1,000 background processes, and I used all
the cores and processors on my machine. 

The code won't make much sense, but by about half way through the
book, you'll be writing this kind of thing for yourself.

<sidebar>
    <title>Source file naming</title>

    <p>
      Source file names are written in lower case with
      underscores. They will have the extension <ic>.ex</ic> for
      programs that you intend to compile into binary form, and
      <ic>.exs</ic> for scripts that you want to run without
      compiling.
    </p>
    
    <p>
      The PMap example used <ic>.exs</ic>, as it was essentially
      throw-away code.
    </p>
</sidebar>    



### Functions are Data Transformers

Elixir lets us solve the problem in the same way the Unix shell
does. Rather than have command line utilities, we have functions. And
we can string them together as we please. The smaller—more
focused—those functions, the more flexibility we have when combining
them.

If we want, we can make these functions run in parallel—Elixir has a
simple but powerful mechanism for passing messages between them. And
these are not your father's boring old processes or threads—we're
talking about the potential to run millions of them on a single
machine, and having hundreds of these machines interoperating. Bruce
Tate commented on this paragraph with "most programmers treat threads
and processes as a necessary evil; Elixir developers feel they are an
important simplification." As we get deeper into the book, you'll
start to see what he means.


This idea of transformation lies at the heart of functional
programming: a function transforms its inputs into its output. The
trigonometric function _sin_ is an example—give it
<fraction><top>π</top><bottom>4</bottom></fraction>, and you'll get
back 0.7071…. An HTML templating system is a function; it takes a
template containing placeholders and some kind of list of named
values, and produces a completed HTML document.

But this power comes at a price. You're going to have to unlearn a
whole lot of what you _know_ about programming. Many of your instincts
will be wrong. And this will be frustrating, because you're going to
feel like a total n00b. 

Personally, I feel that's part of the fun.

You didn't learn (say) object-oriented programming overnight. You are
unlikely to become a functional programming expert by breakfast,
either.

But at some point, things will click. You'll start thinking about
problems in a different way, and you'll find yourself writing code
that does amazing things with very little effort on your part. You'll
find yourself writing small chunks of code that can be used over and
over, often in unexpected ways (just as `wc` and `grep` can be).

Your
view of the world may even change a little, as you stop thinking of
things in terms of responsibilities and start thinking in terms of
getting things done.

And just about everyone can agree that will be fun. 


## Installing Elixir

The most up-to-date instructions for installing Elixir are available
online at <url>http://elixir-lang.org/getting_started/1.html</url>. Go
install it now….

## Running Elixir

In this book, I show a terminal session like this:

{: language="session"}
~~~
$ echo Hello, World
Hello, World
~~~

The terminal prompt is the dollar sign, and the stuff you type
follows. (On your system, the prompt will be different). Output from
the system is shown without highlighting.

### iex—Interactive Elixir

To test that your Elixir installation was successful, let's start
an interactive Elixir session. At your regular shell prompt, type
`iex`.

<iex test="no">
$ iex
Erlang R16B (erts-5.10.1) [source] [64-bit] [smp:2:2] [async-threads:10] 
     [hipe] [kernel-poll:false] [dtrace]

Interactive Elixir (x.y) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
</iex>

(The various version numbers you see will likely be different—we won't
bother to show them on subsequent examples.)

Once you have an iex prompt, you can enter Elixir code, and you'll see
the result. If you enter an expression that continues over more than one
line, iex will prompt for the additional lines with an ellipsis (…).

<iex test="no">
iex(2)> 3 + 7
10
iex(3)> 5 *
...(3)> 8
40
iex(4)>
</iex>

The number in the prompt increments for each complete expression
executed. I'll omit the number in most of the examples that follow.

As well as Elixir code, iex has a number of helper functions. Type
<keystroke>h</keystroke> (followed by return) to get a list:

<iex test="no">
iex> h
</iex>

~~~
# IEx.Helpers
Welcome to Interactive Elixir. You are currently
seeing the documentation for the module IEx.Helpers
which provides many helpers to make Elixir's shell
more joyful to work with.

This message was triggered by invoking the helper
`h()`, usually referred as `h/0` (since it expects 0
arguments).

There are many other helpers available:

* `c/2`     — compiles a file at the given path
* `cd/1`    — changes the current directory
* `clear/0` — clears the screen
* `flush/0` — flushes all messages sent to the shell
* `h/0`     — prints this help
* `h/1`     — prints help for the given module, function or macro
* `l/1`     — loads the given module's beam code and purges the current version
* `ls/0`    — lists the contents of the current directory
* `ls/1`    — lists the contents of the specified directory
* `m/0`     — prints loaded modules
* `pwd/0`   — prints the current working directory
* `r/0`     — recompile and reload all modules that were previously reloaded
*  r/1`     — recompiles and reloads the given module's source file
* `s/1`     — prints spec information
* `t/1`     — prints type information
* `v/0`     — prints the history of commands evaluated in the session
* `v/1`     — retrieves the nth value from the history
* `import_file/1`
            — evaluates the given file in the shell's context

Help for functions in this module can be consulted
directly from the command line, as an example, try:

    h(c/2)

You can also retrieve the documentation for any module
or function. Try these:

    h(Enum)
    h(Enum.reverse/1)

~~~

In the list of helper functions, the number following the slash is the
number of arguments the helper expects. 

Probably the most useful is `h` itself. With an argument, it gives you
help on Elixir modules or individual functions in a module. This works
for any modules loaded into iex (so, later on, when we talk about
projects, you'll see your own documentation here, too).

For example, the IO module performs common I/O functions. For help on
the module, type `h(IO)` or `h IO`.

<iex test="no">
iex> h IO     # or...
iex> h(IO)
</iex>

~~~
Module responsible for doing IO. Many functions in this
module expects an IO device and data encoded in UTF-8.

An IO device must be a pid or an atom representing a process.
For convenience, Elixir provides `:stdio` and `:stderr` as
shortcut to Erlang's `:standard_io` and `:standard_error`.

An io data can be:

* A list of integers representing a string. Any unicode
  character must be represented with one entry in the list,
  this entry being an integer with the codepoint value;

* A binary in which unicode characters are represented
  with many bytes (Elixir's default representation);

* A list of binaries or a list of char lists (as described above);

* If none of the above, `to_binary` is invoked in the
  given argument;
~~~

(Don't worry about all the "list of integers" and "binaries" stuff—there's a
whole chapter about it later.)

This book frequently uses the `puts` function in the `IO`
module. Let's get the documentation.

<iex test="no">
iex> h IO.puts
</iex>

~~~
* def puts(device // group_leader(), item)

Writes the argument to the device, similarly to write
but adds a new line at the end. The argument is expected
to be a chardata.
~~~

There are several ways of exiting from iex—none are tidy. The easiest two
are either typing control-C twice, or typing control-G followed
by <keystroke>q</keystroke> and return.

iex is a surprisingly powerful tool. You can use it to compile and
execute entire projects, log in to remote machines, and access already
running Elixir applications. 

#### Customizing iex

You can customize iex by setting options. For example, I like showing
the results of evaluations in bright cyan. To find how to do that, I used

<iex test="no">
iex> IEx.Options.print_help :colors
This is an aggregate option that encapsulates all color settings used by the
shell. See documentation for the `IO.ANSI` module for the list of supported
colors and attributes.

The value is a keyword list. List of supported keys:

  * enabled     -- boolean value that allows for switching the coloring
                   on and off

  * eval_result -- color for an expression's resulting value
  * error       -- color for error messages
  * info        -- color for various informational messages
  * directory   -- color for directory entries (ls helper)
  * device      -- color for device entries (ls helper)
</iex>

I then created a file called `.iex` in my home directory, containing
the following.

<elixir> 
IEx.Options.set :colors, eval_result: :"cyan,bright" 
</elixir>


If your iex session looks messed up (and there are things such as
`[33m` appearing in the output, it's likely your console does not
support ANSI escape sequences. In that case, disable colorization
using

<elixir>
IEx.Options.set(:colors, [enabled: false])
</elixir>

You can put any Elixir code into `.iex`.


### Compile and Run 

Once you tire of writing one-line programs in iex, you'll want to
start putting code into source files. These files will typically have
the extension `.ex` or `.exs`. This is a convention—files ending `.ex`
are intended to be compiled into bytecodes and then run, whereas those
ending `.exs` are more like programs in scripting languages—they are
effectively interpreted at the source level. When we come to write
tests for our Elixir programs, you'll see that the application files
have `.ex` extensions, while the tests have `.exs`, as we don't need
to keep compiled versions of the tests lying around.

Let's write the classic first program. Go to a working directory and
create a file called `hello.exs`. 

<embed file="code/intro/hello.exs"/>

(The previous example shows how most of the code listings in this book
are presented. The bar before the code itself shows the path and
filename that contains the code. If you're reading an ebook, you'll be
able to click on this to download the source file. You can also
download all the code by visiting the book's page on our
site[^fn-book] and clicking on the _Source Code_ link.)

[^fn-book]: <url>http://pragprog.com/titles/elixir</url>

![](images/source_code.png)


Having created our source file, let's run it. In the same directory
where you created the file, run the `elixir` command:

{: language="session"}
~~~
$ elixir hello.exs
Hello, World!
~~~

We can also compile and run it inside iex using the `c` helper.

<iex test="no">
$ iex
iex> c "hello.exs"
Hello, World!
[]
iex>
</iex>

The `c` helper compiled and executed the source file. (The `[]` that
follows the output is the return value of the `c` function—if the
source file had contained any modules, their names would have been
listed here.

The `c` helper compiled the source file as free-standing code. You can
also load a file as if you'd typed each line into iex using
`import_file`. In this case, local variables set in the file are
available in the iex session.


As some folks fret over such things, the Elixir convention is to use
two column indentation and spaces (not tabs).

## Suggestions for Reading the Book

This book is not a top-to-bottom reference guide to Elixir. Instead,
it is intended to give you enough information to know what questions to
ask, and where to ask them. So try to approach what follows with a
spirit of adventure. Try the code as you read, and don't stop
there. Ask yourself questions, and then try to answer
them, either by coding or searching the web.

Participate in the book's discussion forums[^fn-discuss] and consider
joining the Elixir mailing list.[^fn-ml]

[^fn-discuss]: <url>http://forums.pragprog.com/forums/elixir</url>

[^fn-ml]: <url>https://groups.google.com/forum/?fromgroups#!forum/elixir-lang-talk</url>


You're joining the Elixir community while
it is still young. Things are exciting and dynamic, and there are
plenty of opportunities  to contribute.

## Exercises

You'll find exercises sprinkled throughout the book. If you're reading
an ebook, then each exercise will link directly to a topic in our
online forums. There you'll find an initial answer, along with
discussions of alternatives from readers of the book.

If you're reading this book on paper, visit
[forums.pragprog.com/forums/322](http://forums.pragprog.com/forums/322)
to see the list of exercise topics.


## Think Different(ly)

This is a book about thinking differently; about accepting that
some of the things that folks say about programming may not be the
full story. 

* Object-Orientation is not the only way to design code.
* Functional programming need not be complex or mathematical.
* The foundations of programming are not assignment, if statements, and loops.
* Concurrency does not need locks, semaphores, monitors, and the like.
* Processes are not necessarily expensive resources.
* Metaprogramming is not just something tacked onto a language.
* Even if it is work, programming should be fun.

Of course, I'm not saying that Elixir is a magic potion (well,
technically it is, but you know what I mean). There isn't the ONE TRUE
WAY to write code. But Elixir is different enough from the mainstream
that learning it will give you more perspective and it will open your
mind to new ways of thinking about programming.

So let's start.

And remember to make it fun.

## Acknowledgements

